<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>MeelGroup on MeelGroup</title>
    <link>/</link>
    <description>Recent content in MeelGroup on MeelGroup</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2019</copyright>
    <lastBuildDate>Tue, 09 Jul 2019 00:00:00 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>ApproxMC</title>
      <link>/software/approxmc/</link>
      <pubDate>Tue, 09 Jul 2019 00:00:00 +0800</pubDate>
      
      <guid>/software/approxmc/</guid>
      <description>&lt;p&gt;ApproxMC is a hashing-based algorithm for approximate discrete integration over finite domains and provides ($\epsilon$,$\delta$) guarantees. This implementation handles the case when the function is implicitely defined by SAT formula. To the best of our knowledge, the current implementation has the best runtime performance among approximate counting algorithms. We are actively improving algorithm as well as implementation and would love to hear your feedback.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Relevant Papers:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.comp.nus.edu.sg/~meel/Papers/ijcai16_counting.pdf&#34; title=&#34;IJCAI 2016&#34; target=&#34;_blank&#34;&gt;IJCAI 2016&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.comp.nus.edu.sg/~meel/Papers/constraints16.pdf&#34; title=&#34;Constraints 2016&#34; target=&#34;_blank&#34;&gt;Constraints 2016&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.comp.nus.edu.sg/~meel/Papers/CP2013.pdf&#34; title=&#34;CP 2013&#34; target=&#34;_blank&#34;&gt;CP 2013&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>CrystalBall</title>
      <link>/software/crystalball/</link>
      <pubDate>Sun, 07 Jul 2019 00:00:00 +0800</pubDate>
      
      <guid>/software/crystalball/</guid>
      <description>&lt;p&gt;Boolean satisfiability is a fundamental problem in computerscience with a wide range of applications including planning, configurationmanagement, design and verification of software/hardware systems. Modern SAT solvers achieve scalability and ro-bustness with sophisticated heuristics that are challenging to understandand explain. We propose to view modern conflict-driven clause learning (CDCL) solvers as a composition of classifiers and regressors for different tasks such as branching, clause memory management, and restarting. The current version of CrystalBall focuses on deriving a classifier to keep or throw away a learned clause. In a departure from recent machine learning based techniques, CrystalBall employs supervised learning anduses extensive, multi-gigabyte data extracted from runs of a single SAT solver to perform predictive analytics. Read this &lt;a href=&#34;https://www.msoos.org/2019/06/crystalball-sat-solving-data-gathering-and-machine-learning/&#34; target=&#34;_blank&#34;&gt;blog post&lt;/a&gt; for more details.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Relevant Papers:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.msoos.org/wordpress/wp-content/uploads/2019/06/sat19-skm.pdf&#34; title=&#34;SAT 2019&#34; target=&#34;_blank&#34;&gt;SAT 2019&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>UniGen</title>
      <link>/software/unigen/</link>
      <pubDate>Mon, 01 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>/software/unigen/</guid>
      <description>&lt;p&gt;UniGen is a hashing-based algorithm to generate uniform samples subject to given set of constraints. The primary application of UniGen is in random stimuli generation for hardware and software verification. The current version of the tool has been developed over the years and is parallelizable without losing theoretical guarantees.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Relevant Papers:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.comp.nus.edu.sg/~meel/Papers/Tacas15.pdf&#34; title=&#34;TACAS 2015&#34; target=&#34;_blank&#34;&gt;TACAS 2015&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.comp.nus.edu.sg/~meel/Papers/DAC2014.pdf&#34; title=&#34;DAC 2014&#34; target=&#34;_blank&#34;&gt;DAC 2014&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.comp.nus.edu.sg/~meel/Papers/cav13.pdf&#34; title=&#34;CAV 2013&#34; target=&#34;_blank&#34;&gt;CAV 2013&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title> Interpretable Classification Rules in Relaxed Logical Form </title>
      <link>/publication/ijcai19_irr/</link>
      <pubDate>Sun, 23 Jun 2019 00:00:00 +0800</pubDate>
      
      <guid>/publication/ijcai19_irr/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Our paper on &lt;a href= &#34;https://bishwamittra.github.io/publication/irr-ghosh.pdf&#34;&gt;interpretable rules expressed as relaxed-CNF&lt;/a&gt; is accepted at IJCAI workshop on XAI (Explainable Artificial Intelligence) and DSO (Data Science meets Optimization), 2019. Authors: Bishwamittra Ghosh, Dmitry Malioutov, Kuldeep S. Meel.</title>
      <link>/news/23062019/</link>
      <pubDate>Sun, 23 Jun 2019 00:00:00 +0800</pubDate>
      
      <guid>/news/23062019/</guid>
      <description></description>
    </item>
    
    <item>
      <title>GANAK</title>
      <link>/software/ganak/</link>
      <pubDate>Sat, 15 Jun 2019 00:00:00 +0800</pubDate>
      
      <guid>/software/ganak/</guid>
      <description>&lt;p&gt;Given a Boolean formula $F$, the problem of  model counting, also referred to as #SAT, seeks to compute the number of solutions of $F$. Model counting is a fundamental problem with a wide variety of applications ranging from planning, quantified information flow to probabilistic reasoning and the like. The modern #SAT solvers tend to be either based on static decomposition, dynamic decomposition, or a hybrid of the two. Despite dynamic decomposition based #SAT solvers sharing much of their architecture with SAT solvers, the core design and heuristics of dynamic decomposition-based #SAT solvers has remained constant for over a decade. In this paper, we revisit the architecture of the state-of-the-art dynamic decomposition-based #SAT tool, sharpSAT, and demonstrate that by introducing a new notion of probabilistic component caching and the usage of universal hashing for exact model counting along with the development of several new heuristics can lead to significant performance improvement over state-of-the-art model-counters. In particular, we develop GANAK, a new scalable probabilistic exact model counter that outperforms state-of-the-art exact and approximate model counters sharpSAT and ApproxMC3 respectively, both in terms of PAR-2 score and the number of instances solved. Furthermore, in our experiments, the model count returned by GANAK was equal to the exact model count for all the benchmarks. Finally, we observe that recently proposed preprocessing techniques for model counting benefit exact model counters while hurting the performance of approximate model counters.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Relevant Papers:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.comp.nus.edu.sg/~meel/Papers/ijcai19srsm.pdf&#34; title=&#34;IJCAI 2019&#34; target=&#34;_blank&#34;&gt;IJCAI 2019&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Network Reliability Estimation in Theory and Practice </title>
      <link>/publication/ress/</link>
      <pubDate>Sat, 01 Jun 2019 00:00:00 +0800</pubDate>
      
      <guid>/publication/ress/</guid>
      <description></description>
    </item>
    
    <item>
      <title>GANAK: A Scalable Probabilistic Exact Model Counter</title>
      <link>/publication/ijcai19_ganak/</link>
      <pubDate>Tue, 21 May 2019 00:00:00 +0800</pubDate>
      
      <guid>/publication/ijcai19_ganak/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Phase Transition Behavior of Cardinality and XOR Constraints  </title>
      <link>/publication/ijcai19_cardxor/</link>
      <pubDate>Mon, 20 May 2019 00:00:00 +0800</pubDate>
      
      <guid>/publication/ijcai19_cardxor/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Kuldeep recieved notification of the award of &lt;a href= &#34;https://www.nrf.gov.sg/funding-grants/nrf-fellowship-for-artificial-intelligence&#34;&gt; NRF Fellowship for AI &lt;/a&gt; for the project: Provably Verified and Explainable Probabilistic Reasoning.</title>
      <link>/news/15052019/</link>
      <pubDate>Wed, 15 May 2019 00:00:00 +0800</pubDate>
      
      <guid>/news/15052019/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Two papers accepted to IJCAI.The first paper explores the phase transition behavior of conjunction of cardinality and XOR constraints. Authors: Yash Pote, Saurabh Joshi, Kuldeep Meel.&lt;br&gt; The second paper describes a radically new approach to exact counting wherein we compute estimates that are probabilistically exact! Authors: Shubham Sharma, Kuldeep Meel. Combined with our invited paper on &lt;a href= &#34;https://www.comp.nus.edu.sg/~meel/Papers/CP2018msv.pdf&#34;&gt; #DNF &lt;/a&gt;, this makes 3 papers that we will be presenting at IJCAI.</title>
      <link>/news/09052019/</link>
      <pubDate>Thu, 09 May 2019 00:00:00 +0800</pubDate>
      
      <guid>/news/09052019/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Assessing Heuristic Machine Learning Explanations with Model Counting  </title>
      <link>/publication/sat19_heu/</link>
      <pubDate>Sun, 05 May 2019 00:00:00 +0800</pubDate>
      
      <guid>/publication/sat19_heu/</guid>
      <description></description>
    </item>
    
    <item>
      <title>CrystalBall: Gazing in the Black Box of SAT Solving </title>
      <link>/publication/sat19_cball/</link>
      <pubDate>Sun, 05 May 2019 00:00:00 +0800</pubDate>
      
      <guid>/publication/sat19_cball/</guid>
      <description></description>
    </item>
    
    <item>
      <title>ApproxMCv3: A modern approximate model counter</title>
      <link>/post/approxmcv3/</link>
      <pubDate>Fri, 03 May 2019 11:06:17 +0530</pubDate>
      
      <guid>/post/approxmcv3/</guid>
      <description>&lt;p&gt;This blogpost and its underlying work has been brewing for many years, and I&amp;#8217;m extremely happy to be able to share it with you now. Kuldeep Meel and myself have been working very hard on speeding up approximate model counting for SAT and I think we have made real progress. The research paper, accepted at AAAI-19 is available &lt;a href=&#34;https://www.comp.nus.edu.sg/~meel/Papers/aaai19-sm.pdf&#34;&gt;here&lt;/a&gt;. The code is available &lt;a href=&#34;https://github.com/meelgroup/ApproxMC&#34;&gt;here&lt;/a&gt; (release with static binary &lt;a href=&#34;https://github.com/meelgroup/ApproxMC/releases&#34;&gt;here&lt;/a&gt;). The main result is that we can solve a &lt;strong&gt;lot&lt;/strong&gt; more problems than before. The speed of solving is orders(!) of magnitude faster than the previous best system:&lt;/p&gt;
&lt;p&gt;&lt;img class=&#34;size-full wp-image-3214 aligncenter&#34; src=&#34;http://www.msoos.org/wordpress/wp-content/uploads/2018/11/Screenshot_20181125_202611.png&#34; alt=&#34;&#34; width=&#34;1202&#34; height=&#34;740&#34; srcset=&#34;https://www.msoos.org/wordpress/wp-content/uploads/2018/11/Screenshot_20181125_202611.png 1202w, https://www.msoos.org/wordpress/wp-content/uploads/2018/11/Screenshot_20181125_202611-300x185.png 300w, https://www.msoos.org/wordpress/wp-content/uploads/2018/11/Screenshot_20181125_202611-768x473.png 768w, https://www.msoos.org/wordpress/wp-content/uploads/2018/11/Screenshot_20181125_202611-1024x630.png 1024w&#34; sizes=&#34;(max-width: 1202px) 100vw, 1202px&#34; /&gt;&lt;/p&gt;
&lt;h3&gt;Background&lt;/h3&gt;
&lt;p&gt;The idea of approximate model counting, originally &lt;a href=&#34;https://arxiv.org/pdf/1306.5726&#34;&gt;by Chakraborty, Meel and Vardi&lt;/a&gt; was a huge hit back in 2013, and many papers have followed it, trying to improve its results. All of them were basically tied to &lt;a href=&#34;https://github.com/msoos/cryptominisat&#34;&gt;CryptoMiniSat&lt;/a&gt;, the SAT solver that I maintain, as all of them relied on XOR constraints being added to the regular CNF of a typical SAT problem.&lt;/p&gt;
&lt;p&gt;So it made sense to examine what CryptoMiniSat could do to improve the speed of approximate counting. This time interestingly coincided with me giving up on XORs in CryptoMiniSat. The problem was the following. A lot of new in- and preprocessing systems were being invented, mostly by Armin Biere et al, and I quickly realised that I simply couldn&amp;#8217;t keep adding them, because they didn&amp;#8217;t take into account XOR constraints. They handled CNF just fine, but not XORs. So XORs became a burden, and I removed them in versions 3 and 4 of CryptoMiniSat. But there was need, and Kuldeep made it very clear to me that this is an exciting area. So, they had to come back.&lt;/p&gt;
&lt;h3&gt;Blast-Inprocess-Recover-Destroy&lt;/h3&gt;
&lt;p&gt;But how to both have and not have XOR constraints? Re-inventing all the algorithms for XORs was not a viable option. The solution I came up with was a rather trivial one: forget the XORs during inprocessing and recover them after. The CNF would always remain the source of truth. Extracting all the XORs after in- and preprocessing would allow me to run the Gauss-Jordan elimination on the XORs post-recovery. So I can have the cake and eat it too.&lt;/p&gt;
&lt;p&gt;The process is conceptually quite easy:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Blast&lt;/strong&gt; all XORs into clauses that are in the input using intermediate variables. I had all the setup for this, as I was doing &lt;a href=&#34;https://link.springer.com/chapter/10.1007%2F978-3-642-39611-3_14&#34;&gt;Bounded Variable Addition&lt;/a&gt;  (also by Biere et al.) so I didn&amp;#8217;t have to write code to &amp;#8220;hide&amp;#8221; these additional variables.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Perform&lt;/strong&gt; &lt;strong&gt;pre- or inprocessing&lt;/strong&gt;. I actually only do inprocessing nowadays (as it has faster startup time). But preprocessing is just inprocessing at the start ;)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Recover the XORs&lt;/strong&gt; from the CNF. There were some trivial methods around. They didn&amp;#8217;t work as well as one would have hoped, but more on that later&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Run the CDCL and Gauss-Jordan&lt;/strong&gt; code at the same time.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Destroy the XORs&lt;/strong&gt; and goto 2.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This system allows for everything to be in CNF form, lifting the XORs out when necessary and then forgetting them when it&amp;#8217;s convenient. All of these steps are rather trivial, except, as I later found out, recovery.&lt;/p&gt;
&lt;h3&gt;XOR recovery&lt;/h3&gt;
&lt;p&gt;Recovering XORs sounds like a trivial task. Let&amp;#8217;s say we have the following clauses&lt;/p&gt;&lt;!-- Crayon Syntax Highlighter v_2.7.2_beta --&gt;

        &lt;div id=&#34;crayon-5d2d8a4cc360b169129534&#34; class=&#34;crayon-syntax crayon-theme-classic crayon-font-monaco crayon-os-pc print-yes notranslate&#34; data-settings=&#34; no-popup minimize scroll-mouseover&#34; style=&#34; margin-top: 12px; margin-bottom: 12px; font-size: 12px !important; line-height: 15px !important;&#34;&gt;
        
            &lt;div class=&#34;crayon-toolbar&#34; data-settings=&#34; show&#34; style=&#34;font-size: 12px !important;height: 18px !important; line-height: 18px !important;&#34;&gt;&lt;span class=&#34;crayon-title&#34;&gt;&lt;/span&gt;
            &lt;div class=&#34;crayon-tools&#34; style=&#34;font-size: 12px !important;height: 18px !important; line-height: 18px !important;&#34;&gt;&lt;div class=&#34;crayon-button crayon-nums-button&#34; title=&#34;Toggle Line Numbers&#34;&gt;&lt;div class=&#34;crayon-button-icon&#34;&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;crayon-button crayon-plain-button&#34; title=&#34;Toggle Plain Code&#34;&gt;&lt;div class=&#34;crayon-button-icon&#34;&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;crayon-button crayon-wrap-button&#34; title=&#34;Toggle Line Wrap&#34;&gt;&lt;div class=&#34;crayon-button-icon&#34;&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;crayon-button crayon-expand-button&#34; title=&#34;Expand Code&#34;&gt;&lt;div class=&#34;crayon-button-icon&#34;&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;crayon-button crayon-copy-button&#34; title=&#34;Copy&#34;&gt;&lt;div class=&#34;crayon-button-icon&#34;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;
            &lt;div class=&#34;crayon-info&#34; style=&#34;min-height: 16.8px !important; line-height: 16.8px !important;&#34;&gt;&lt;/div&gt;
            &lt;div class=&#34;crayon-plain-wrap&#34;&gt;&lt;textarea wrap=&#34;soft&#34; class=&#34;crayon-plain print-no&#34; data-settings=&#34;dblclick&#34; readonly style=&#34;-moz-tab-size:4; -o-tab-size:4; -webkit-tab-size:4; tab-size:4; font-size: 12px !important; line-height: 15px !important;&#34;&gt;
 x1 V  x2 V  x3
-x1 V -x2 V  x3
 x1 V -x2 V -x3
-x1 V  x2 V -x3&lt;/textarea&gt;&lt;/div&gt;
            &lt;div class=&#34;crayon-main&#34; style=&#34;&#34;&gt;
                &lt;table class=&#34;crayon-table&#34;&gt;
                    &lt;tr class=&#34;crayon-row&#34;&gt;
                &lt;td class=&#34;crayon-nums &#34; data-settings=&#34;show&#34;&gt;
                    &lt;div class=&#34;crayon-nums-content&#34; style=&#34;font-size: 12px !important; line-height: 15px !important;&#34;&gt;&lt;div class=&#34;crayon-num&#34; data-line=&#34;crayon-5d2d8a4cc360b169129534-1&#34;&gt;1&lt;/div&gt;&lt;div class=&#34;crayon-num&#34; data-line=&#34;crayon-5d2d8a4cc360b169129534-2&#34;&gt;2&lt;/div&gt;&lt;div class=&#34;crayon-num&#34; data-line=&#34;crayon-5d2d8a4cc360b169129534-3&#34;&gt;3&lt;/div&gt;&lt;div class=&#34;crayon-num&#34; data-line=&#34;crayon-5d2d8a4cc360b169129534-4&#34;&gt;4&lt;/div&gt;&lt;/div&gt;
                &lt;/td&gt;
                        &lt;td class=&#34;crayon-code&#34;&gt;&lt;div class=&#34;crayon-pre&#34; style=&#34;font-size: 12px !important; line-height: 15px !important; -moz-tab-size:4; -o-tab-size:4; -webkit-tab-size:4; tab-size:4;&#34;&gt;&lt;div class=&#34;crayon-line&#34; id=&#34;crayon-5d2d8a4cc360b169129534-1&#34;&gt;&lt;span class=&#34;crayon-h&#34;&gt; &lt;/span&gt;&lt;span class=&#34;crayon-i&#34;&gt;x1&lt;/span&gt;&lt;span class=&#34;crayon-h&#34;&gt; &lt;/span&gt;&lt;span class=&#34;crayon-i&#34;&gt;V&lt;/span&gt;&lt;span class=&#34;crayon-h&#34;&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;span class=&#34;crayon-i&#34;&gt;x2&lt;/span&gt;&lt;span class=&#34;crayon-h&#34;&gt; &lt;/span&gt;&lt;span class=&#34;crayon-i&#34;&gt;V&lt;/span&gt;&lt;span class=&#34;crayon-h&#34;&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;span class=&#34;crayon-v&#34;&gt;x3&lt;/span&gt;&lt;/div&gt;&lt;div class=&#34;crayon-line&#34; id=&#34;crayon-5d2d8a4cc360b169129534-2&#34;&gt;&lt;span class=&#34;crayon-o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;crayon-i&#34;&gt;x1&lt;/span&gt;&lt;span class=&#34;crayon-h&#34;&gt; &lt;/span&gt;&lt;span class=&#34;crayon-v&#34;&gt;V&lt;/span&gt;&lt;span class=&#34;crayon-h&#34;&gt; &lt;/span&gt;&lt;span class=&#34;crayon-o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;crayon-i&#34;&gt;x2&lt;/span&gt;&lt;span class=&#34;crayon-h&#34;&gt; &lt;/span&gt;&lt;span class=&#34;crayon-i&#34;&gt;V&lt;/span&gt;&lt;span class=&#34;crayon-h&#34;&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;span class=&#34;crayon-e&#34;&gt;x3&lt;/span&gt;&lt;/div&gt;&lt;div class=&#34;crayon-line&#34; id=&#34;crayon-5d2d8a4cc360b169129534-3&#34;&gt;&lt;span class=&#34;crayon-e&#34;&gt; &lt;/span&gt;&lt;span class=&#34;crayon-i&#34;&gt;x1&lt;/span&gt;&lt;span class=&#34;crayon-h&#34;&gt; &lt;/span&gt;&lt;span class=&#34;crayon-v&#34;&gt;V&lt;/span&gt;&lt;span class=&#34;crayon-h&#34;&gt; &lt;/span&gt;&lt;span class=&#34;crayon-o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;crayon-i&#34;&gt;x2&lt;/span&gt;&lt;span class=&#34;crayon-h&#34;&gt; &lt;/span&gt;&lt;span class=&#34;crayon-v&#34;&gt;V&lt;/span&gt;&lt;span class=&#34;crayon-h&#34;&gt; &lt;/span&gt;&lt;span class=&#34;crayon-o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;crayon-v&#34;&gt;x3&lt;/span&gt;&lt;/div&gt;&lt;div class=&#34;crayon-line&#34; id=&#34;crayon-5d2d8a4cc360b169129534-4&#34;&gt;&lt;span class=&#34;crayon-o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;crayon-i&#34;&gt;x1&lt;/span&gt;&lt;span class=&#34;crayon-h&#34;&gt; &lt;/span&gt;&lt;span class=&#34;crayon-i&#34;&gt;V&lt;/span&gt;&lt;span class=&#34;crayon-h&#34;&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;span class=&#34;crayon-i&#34;&gt;x2&lt;/span&gt;&lt;span class=&#34;crayon-h&#34;&gt; &lt;/span&gt;&lt;span class=&#34;crayon-v&#34;&gt;V&lt;/span&gt;&lt;span class=&#34;crayon-h&#34;&gt; &lt;/span&gt;&lt;span class=&#34;crayon-o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;crayon-v&#34;&gt;x3&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;
                    &lt;/tr&gt;
                &lt;/table&gt;
            &lt;/div&gt;
        &lt;/div&gt;
&lt;!-- [Format Time: 0.0095 seconds] --&gt;
&lt;p&gt;This is conceptually equivalent to the XOR v1+v2+v3=1. So recovering this is trivial, and has been done before, by Heule in particular, in his &lt;a href=&#34;http://www.st.ewi.tudelft.nl/sat/theses/heule_phd.pdf&#34;&gt;PhD thesis&lt;/a&gt;. The issue with the above is the following: a stronger system than the above still implies the XOR, but doesn&amp;#8217;t look the same. Let me give an example:&lt;/p&gt;&lt;!-- Crayon Syntax Highlighter v_2.7.2_beta --&gt;

        &lt;div id=&#34;crayon-5d2d8a4cc3642323236668&#34; class=&#34;crayon-syntax crayon-theme-classic crayon-font-monaco crayon-os-pc print-yes notranslate&#34; data-settings=&#34; no-popup minimize scroll-mouseover&#34; style=&#34; margin-top: 12px; margin-bottom: 12px; font-size: 12px !important; line-height: 15px !important;&#34;&gt;
        
            &lt;div class=&#34;crayon-toolbar&#34; data-settings=&#34; show&#34; style=&#34;font-size: 12px !important;height: 18px !important; line-height: 18px !important;&#34;&gt;&lt;span class=&#34;crayon-title&#34;&gt;&lt;/span&gt;
            &lt;div class=&#34;crayon-tools&#34; style=&#34;font-size: 12px !important;height: 18px !important; line-height: 18px !important;&#34;&gt;&lt;div class=&#34;crayon-button crayon-nums-button&#34; title=&#34;Toggle Line Numbers&#34;&gt;&lt;div class=&#34;crayon-button-icon&#34;&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;crayon-button crayon-plain-button&#34; title=&#34;Toggle Plain Code&#34;&gt;&lt;div class=&#34;crayon-button-icon&#34;&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;crayon-button crayon-wrap-button&#34; title=&#34;Toggle Line Wrap&#34;&gt;&lt;div class=&#34;crayon-button-icon&#34;&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;crayon-button crayon-expand-button&#34; title=&#34;Expand Code&#34;&gt;&lt;div class=&#34;crayon-button-icon&#34;&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;crayon-button crayon-copy-button&#34; title=&#34;Copy&#34;&gt;&lt;div class=&#34;crayon-button-icon&#34;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;
            &lt;div class=&#34;crayon-info&#34; style=&#34;min-height: 16.8px !important; line-height: 16.8px !important;&#34;&gt;&lt;/div&gt;
            &lt;div class=&#34;crayon-plain-wrap&#34;&gt;&lt;textarea wrap=&#34;soft&#34; class=&#34;crayon-plain print-no&#34; data-settings=&#34;dblclick&#34; readonly style=&#34;-moz-tab-size:4; -o-tab-size:4; -webkit-tab-size:4; tab-size:4; font-size: 12px !important; line-height: 15px !important;&#34;&gt;
 x1 V  x2 V  x3
-x1 V -x2 V  x3
 x1 V -x2 V -x3
-x1 V  x2&lt;/textarea&gt;&lt;/div&gt;
            &lt;div class=&#34;crayon-main&#34; style=&#34;&#34;&gt;
                &lt;table class=&#34;crayon-table&#34;&gt;
                    &lt;tr class=&#34;crayon-row&#34;&gt;
                &lt;td class=&#34;crayon-nums &#34; data-settings=&#34;show&#34;&gt;
                    &lt;div class=&#34;crayon-nums-content&#34; style=&#34;font-size: 12px !important; line-height: 15px !important;&#34;&gt;&lt;div class=&#34;crayon-num&#34; data-line=&#34;crayon-5d2d8a4cc3642323236668-1&#34;&gt;1&lt;/div&gt;&lt;div class=&#34;crayon-num&#34; data-line=&#34;crayon-5d2d8a4cc3642323236668-2&#34;&gt;2&lt;/div&gt;&lt;div class=&#34;crayon-num&#34; data-line=&#34;crayon-5d2d8a4cc3642323236668-3&#34;&gt;3&lt;/div&gt;&lt;div class=&#34;crayon-num&#34; data-line=&#34;crayon-5d2d8a4cc3642323236668-4&#34;&gt;4&lt;/div&gt;&lt;/div&gt;
                &lt;/td&gt;
                        &lt;td class=&#34;crayon-code&#34;&gt;&lt;div class=&#34;crayon-pre&#34; style=&#34;font-size: 12px !important; line-height: 15px !important; -moz-tab-size:4; -o-tab-size:4; -webkit-tab-size:4; tab-size:4;&#34;&gt;&lt;div class=&#34;crayon-line&#34; id=&#34;crayon-5d2d8a4cc3642323236668-1&#34;&gt;&lt;span class=&#34;crayon-h&#34;&gt; &lt;/span&gt;&lt;span class=&#34;crayon-i&#34;&gt;x1&lt;/span&gt;&lt;span class=&#34;crayon-h&#34;&gt; &lt;/span&gt;&lt;span class=&#34;crayon-i&#34;&gt;V&lt;/span&gt;&lt;span class=&#34;crayon-h&#34;&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;span class=&#34;crayon-i&#34;&gt;x2&lt;/span&gt;&lt;span class=&#34;crayon-h&#34;&gt; &lt;/span&gt;&lt;span class=&#34;crayon-i&#34;&gt;V&lt;/span&gt;&lt;span class=&#34;crayon-h&#34;&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;span class=&#34;crayon-v&#34;&gt;x3&lt;/span&gt;&lt;/div&gt;&lt;div class=&#34;crayon-line&#34; id=&#34;crayon-5d2d8a4cc3642323236668-2&#34;&gt;&lt;span class=&#34;crayon-o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;crayon-i&#34;&gt;x1&lt;/span&gt;&lt;span class=&#34;crayon-h&#34;&gt; &lt;/span&gt;&lt;span class=&#34;crayon-v&#34;&gt;V&lt;/span&gt;&lt;span class=&#34;crayon-h&#34;&gt; &lt;/span&gt;&lt;span class=&#34;crayon-o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;crayon-i&#34;&gt;x2&lt;/span&gt;&lt;span class=&#34;crayon-h&#34;&gt; &lt;/span&gt;&lt;span class=&#34;crayon-i&#34;&gt;V&lt;/span&gt;&lt;span class=&#34;crayon-h&#34;&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;span class=&#34;crayon-e&#34;&gt;x3&lt;/span&gt;&lt;/div&gt;&lt;div class=&#34;crayon-line&#34; id=&#34;crayon-5d2d8a4cc3642323236668-3&#34;&gt;&lt;span class=&#34;crayon-e&#34;&gt; &lt;/span&gt;&lt;span class=&#34;crayon-i&#34;&gt;x1&lt;/span&gt;&lt;span class=&#34;crayon-h&#34;&gt; &lt;/span&gt;&lt;span class=&#34;crayon-v&#34;&gt;V&lt;/span&gt;&lt;span class=&#34;crayon-h&#34;&gt; &lt;/span&gt;&lt;span class=&#34;crayon-o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;crayon-i&#34;&gt;x2&lt;/span&gt;&lt;span class=&#34;crayon-h&#34;&gt; &lt;/span&gt;&lt;span class=&#34;crayon-v&#34;&gt;V&lt;/span&gt;&lt;span class=&#34;crayon-h&#34;&gt; &lt;/span&gt;&lt;span class=&#34;crayon-o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;crayon-v&#34;&gt;x3&lt;/span&gt;&lt;/div&gt;&lt;div class=&#34;crayon-line&#34; id=&#34;crayon-5d2d8a4cc3642323236668-4&#34;&gt;&lt;span class=&#34;crayon-o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;crayon-i&#34;&gt;x1&lt;/span&gt;&lt;span class=&#34;crayon-h&#34;&gt; &lt;/span&gt;&lt;span class=&#34;crayon-i&#34;&gt;V&lt;/span&gt;&lt;span class=&#34;crayon-h&#34;&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;span class=&#34;crayon-v&#34;&gt;x2&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;
                    &lt;/tr&gt;
                &lt;/table&gt;
            &lt;/div&gt;
        &lt;/div&gt;
&lt;!-- [Format Time: 0.0081 seconds] --&gt;
&lt;p&gt;This is almost equivalent to the previous set of clauses, but misses a literal from one of the clauses. It still implies the XOR of course. Now what? And what to do when missing literals mean that an entire clause can be missing? The algorithm to recover XORs in such cases is non-trivial. It&amp;#8217;s non-trivial not only because of the complexity of how many combinations of missing literals and clauses there can be (it&amp;#8217;s exponential) but because one must do this work extremely fast because SAT solvers are sensitive to time.&lt;/p&gt;
&lt;p&gt;The algorithm that is in the &lt;a href=&#34;https://www.comp.nus.edu.sg/~meel/Papers/aaai19-sm.pdf&#34;&gt;paper&lt;/a&gt; explains all the bit-fiddling and cache-friendly data layout used along with some fun algorithms that I&amp;#8217;m sure some people will like. We even managed to use compiler intrinsics to use target-specific assembly instructions for hamming weight calculation. It&amp;#8217;s a blast. Take a look.&lt;/p&gt;
&lt;h3&gt;The results&lt;/h3&gt;
&lt;p&gt;The results, as shown above, speak for themselves. Problems that took thousands of seconds to solve can now be solved under 20. The reason for such incredible speedup is basically the following. CryptoMiniSatv2 was way too clunky and didn&amp;#8217;t have all the fun stuff that CryptoMiniSatv5 has, plus the XOR handling was incorrect, loosing XORs and the like. The published algorithm solves the underlying issue and allows CNF pre- and inprocessing to happen independent of XORs, thus enabling CryptoMiniSatv5 to be used in all its glory. And CryptoMiniSatv5 is &lt;em&gt;fast,&lt;/em&gt; as per the this year&amp;#8217;s SAT Competition &lt;a href=&#34;http://sat2018.forsyte.tuwien.ac.at/index.php?cat=results&#34;&gt;results&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;Some closing words&lt;/h3&gt;
&lt;p&gt;Finally, I want to say thank you to &lt;a href=&#34;https://www.comp.nus.edu.sg/~meel&#34;&gt;Kuldeep Meel&lt;/a&gt; who got me into the &lt;a href=&#34;http://nus.edu.sg/&#34;&gt;National University of Singapore&lt;/a&gt; to do the work above and lots of other cool work, that we will hopefully publish soon. I would also like to thank the &lt;a href=&#34;https://www.nscc.sg/&#34;&gt;National Supercomputing Center Singapore&lt;/a&gt;  that allowed us to run a ton of benchmarks on their machines, using at least 200 thousand CPU hours to make this paper. This gave us the chance to debug all the weird edge-cases and get this system up to speed where it beats the best exact counters by a wide margin. Finally, thanks to all the great people I had the chance to meet and sometimes work with at NUS, it was a really nice time.&lt;/p&gt;

&lt;p&gt;This post has been adapted from &lt;a href=&#34;https://www.msoos.org/2018/11/approxmcv3-a-modern-approximate-model-counter/&#34;&gt;Mate&#39;s post&lt;/a&gt; on ApproxMCv3.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Knowledge Compilation meets Uniform Sampling</title>
      <link>/post/kus/</link>
      <pubDate>Fri, 03 May 2019 11:06:17 +0530</pubDate>
      
      <guid>/post/kus/</guid>
      <description>&lt;p&gt;This blogpost is based on our (&lt;a href=&#34;https://smsharma1.github.io/&#34; target=&#34;_blank&#34;&gt;Shubham&lt;/a&gt;, &lt;a href=&#34;https://rahulguptakota.github.io/&#34; target=&#34;_blank&#34;&gt;Rahul&lt;/a&gt;, &lt;a href=&#34;https://www.cse.iitk.ac.in/users/subhajit/&#34; target=&#34;_blank&#34;&gt;Subhajit&lt;/a&gt; and &lt;a href=&#34;https://www.comp.nus.edu.sg/~meel/&#34; target=&#34;_blank&#34;&gt;Kuldeep&lt;/a&gt;) &lt;a href=&#34;https://www.comp.nus.edu.sg/~meel/Papers/lpar18.pdf&#34; target=&#34;_blank&#34;&gt;paper&lt;/a&gt; that got published in the procedings of International Conference on Logic for Programming, Artificial Intelligence and Reasoning (LPAR), 2018. The code is available &lt;a href=&#34;https://github.com/meelgroup/KUS&#34; target=&#34;_blank&#34;&gt;here&lt;/a&gt;. The primary contribution of this work is marrying knowledge compilation with uniform sampling to design a new uniform sampler KUS. The main result is that KUS is able to solve more number of benchmarks than existing state-of-the-art uniform and almost-uniform samplers beating them by orders of magnitude in terms of runtime:
&lt;img src=&#34;cactus.png&#34; alt=&#34;alt text&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;h3&gt;Uniform Sampling&lt;/h3&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Given a boolean formula $F$, the idea of Uniform Sampling is to generate samples from the set of solutions of $F$ called $R_F$ using a generator $\mathcal{G}$ that guarantees:
$$\forall y \in R_F, \mathsf{Pr}\left[\mathcal{G}(F) = y\right] = \frac{1}{|R_F|},$$
Uniform sampling is a fundamental problem in computer science with wide range of applications ranging from bayesian analysis to software engineering and programming languages. Jerrum, Valiant, and Vazirani observed deep relationship between model counting and uniform sampling. In particular, they showed that given access to an exact model counter, one could design a uniform generator which requires only polynomially many queries to the exact model counter. On the other hand, knowledge compilation has been emerged as a vital task wherein a logical theory is compiled into a form that allows performing probabilistic inference in polynomial time. It is well known that there is a deep connection between probabilistic inference and model counting. In this context, one wonders if the recent advances in knowledge compilation can be harnessed to design a scalable uniform sampler. The primary contribution of this work is marrying knowledge compilation with uniform sampling to design a new algorithm, KUS, that performs uniform sampling, outperforming current state-of-the-art approximately uniform and uniform samplers.&lt;/p&gt;

&lt;p&gt;&lt;h3&gt; Knowledge Compilation and d-DNNF representation&lt;/h3&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;To deal with computational intractability of probabilistic reasoning, knowledge compilation seeks to compile a knowledge base, often represented as a propositional formula in CNF, to a target language. Thereafter, probabilistic reasoning tasks, which are often expressed as sequence of queries, are performed by querying the knowledge base in the target language. Deterministic Decomposable Negation Normal Form (d-DNNF) have emerged as a central target language in knowledge compilation community since several probabilistic reasoning tasks such as probabilistic inference, maximum a posteriori (MAP) can be answered in polynomial time in the size of d-DNNF. A boolean formula in Negation Normal Form (NNF) is said to be in d-DNNF if it satisfes the following properties:
&lt;ul&gt;
&lt;li&gt; Deterministic: We refer to an NNF as deterministic if the operands of OR in all wellformed Boolean formula in the NNF are mutually inconsistent.&lt;/li&gt;
&lt;li&gt;Decomposable: We refer to an NNF as decomposable if the operands of AND in all wellformed Boolean formula in the NNF are expressed in a mutually disjoint set of variables.&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&#34;ddnnf.png&#34; alt=&#34;alt_text&#34; /&gt;&lt;/p&gt;

&lt;p&gt;d-DNNF of a boolean formula $F$ represent the set of satisfying assignment $R_F$
&lt;h3&gt;The algorithm&lt;/h3&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;The central idea behind KUS is to first employ the state-of-the-art knowledge compilation approaches to compile a given CNF formula into d-DNNF form, and then performing only two passes over the d-DNNF representation to generate as many identically and independently distributed samples as specified by the user denoted by $s$.
&lt;img src=&#34;kus.png&#34; alt=&#34;alt_text&#34; /&gt;&lt;/p&gt;

&lt;p&gt;KUS takes in a CNF formula $F$ and required number of samples s and returns a set of $s$ samples such that each sample is uniformly and independently drawn from the uniform distribution over the set of solutions $R_F$. KUS first invokes a d-DNNF compiler over the formula F to obtain its d-DNNF. Then, the subroutine Annotate is invoked that annotates d-DNNF by annotating each node with a tuple consisting of the number of solutions and the set of variables in the node&amp;rsquo;s corresponding sub-formula. Then, the subroutine Sampler is invoked that returns s uniformly and independently drawn samples using the properties of d-DNNF. Finally, KUS gives random assignment to the unassigned variables for each sample in the SampleList to account for unconstrained variables that do not appear in d-DNNF by invoking the subroutine RandomAssignment.
&lt;h3&gt;The Results&lt;/h3&gt;
Our experiments demonstrated that KUS outperformed both SPUR and UniGen2 state-of-the-art uniform and almost-uniform samplers by a factor of up to $3$ orders of magnitude in terms of runtime in some cases while achieving a geometric speedup of $1.7\times$ and $8.3\times$ over SPUR and UniGen2 respectively. The distribution generated by KUS is statistically indistinguishable from that generated by an ideal uniform sampler. Moreover, KUS is almost oblivious to the number of samples requested. Finally, we observe that KUS can benefit from different d-DNNF compilers, therefore suggesting development of portfolio samplers in future. One of the biggest advantage of KUS is in incremental sampling&amp;ndash;fetching multiple, relatively small-sized samples, repeatedly. The typical use case of iterative sampling can be in repeated invocation of a sampling tool until the objective (such as desired coverage or violation of property) is achieved. In incremental-sampling KUS achieves speedups of upto 3 orders of magnitude.
&lt;h3&gt;Conclusion&lt;/h3&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
&lt;li&gt;In this work, we have proposed a new approach for uniform sampling that builds on breakthrough progress in knowledge compilation&lt;/li&gt;
&lt;li&gt;Experimentally we have demonstrated that KUS outperformed state-of-the-art uniform and almost-uniform samplers&lt;/li&gt;
&lt;li&gt;We believe that the success of KUS will motivate researchers in verification and knowledge compilation communities to investigate a broader set of logical forms amenable to efficient uniform generation&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>
